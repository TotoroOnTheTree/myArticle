

## 特点：

1. 链表和数组在插入、删除、查找的时间复杂度上正好完全相反：

<img src="img/链表/4f63e92598ec2551069a0eef69db7168.jpg" alt="img" style="zoom:33%;" />



2. 数组需要一整块连续的内存空间，而链表通过指针将一组零散的内存块串联起来。
3. 数组对cpu预读更友好







**时间复杂度：** 

​	插入、删除：$O(1)$

​	查找： $O(n)$



## 常见链表：

### 单链表

​	**组成：**结点、后继指针（next)

### 双向链表

​	**组成：**结点、后继指针（next)、前驱指针（prev）

​	在删除给定节点时比单链表高效，因为不用在遍历一遍找到前一个节点是谁。

### 循环链表

​	将单链表的尾结点指向首结点即为循环链表

​	常用于解决 **约瑟夫问题**

### 双向循环链表



## 如何快速写出链表代码

1. 理解指针或引用的含义
2. 警惕指针丢失和内存泄漏
   1. 插入节点时，一定要注意操作顺序。现将下个结点的引用放入要插入节点的next，再去修改上个节点的next指向当前节点。
   2. 删除结点时，记得手动释放空间
3. 利用哨兵简化实现难度
   1. 引入哨兵，可以将第一个结点和最后一个结点的特殊情况转换为普通结点的增删操作。
   2. 带哨兵的叫**带头链表**，不带的叫**不带头链表**
4. 重点留意边界条件
5. 举例画图辅助思考
6. 多写多练，没有捷径





## 实战

### 1. 链表实现

1. 单链表实现 ：见`LinkedListSimple`

2. 单链表+哨兵 ：见`LinkedListSentry（逆序链表）`、`LinkedListSentry2（正序链表）`

3. 双向链表：见`LinkedListDefault`

   



### 2. LRU缓存淘汰算法

#### 策略：

​	FIFO(first in , first out)：先进先出策略

​	LFU(latest frequently used)：最少使用策略

​	LRU(latest recently used)：最近最少使用策略

#### 思路：

维护一个有序链表，越早访问的数据越接近链表尾部

读取数据时，从链表中查找到该结点，如果存在则删除该结点，将其添加到链表头。如果没有找到，则检查链表是否满了，没满则直接添加到头部；满了则删除尾结点，再添加到头部。

见`LinkedListLRU`



### 3. 约瑟夫环问题

约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。



**解题思路一：**使用循环链表，从1计数，数到M就将那个节点删除，一直到最后剩余一个结点时就是他了。

​	实现很简单，暂时没实现。



**解题思路二：**使用公式 $f(N,M)=(f(N−1,M)+M)\%N$

这里主要记录一下思路二的推导过程：

假设有`n=11`个人参与游戏，我们将人员按小写字母编号（`a b c d e ...`），放在一个容量为11的数组中。

![image-20200508234518625](img/链表/image-20200508234518625.png)

这时我们让他们从1开始叫号，叫到3（叫的号我们定义为M）的人出列（删除）。

第一轮：a叫号1，b叫号2，c叫号3。c出列。

第二轮：d从1开始叫号，e叫号2，f叫号3。f出列。

……

如果一直这么叫下去，似乎没什么规律。我们处理一下：因为每次都从1开始叫号，那么一轮结束后，我们将叫到3的人剔除，并将叫号1,2的人放到数组后面去，最后就会像这样：

![轮数图](img/链表/image-20200508234846283.png)

可以看出，每一轮人员的下标都会向前移动3位，而前面的人员移到后面，也是移动3个位置。我们把第一轮，第二轮人员的下标变化用图表示出来：

<img src="img/链表/image-20200511112233268.png" alt="image-20200511112233268" style="zoom:50%;" />

通过观察，很容易发现`d e f g h i j k`的下标变化为减3，而第一个出队的人一定是2的位置。

而`a b`则从0变为8 ，1 变为9，如果将数组想象成一个循环数组，那么很容易可以得出它们的下标变化规律为：

<img src="img/链表/image-20200509001705396.png" alt="image-20200509001705396" style="zoom:50%;" />

>  $y = (x - 3 + 11 ) \%  n $ ，x为原下标，y为变换后的下标
>
>  或者
>
>  $x = (y+3)\%n$

> Ps：通过取余来实现数组的循环是一个很常用的技巧，记住哟。



如果我们叫号的数字为`M` ，总数是`N`，那么公式就变成了：

>  $y = (x - M + N) \% N $，其中`x`为人员在数组中的下标位置，`y`为下一轮的下标位置。
>
>  或者
>
>  $x = (y+M)\%N$



看出什么了吗？每一轮我们将叫到M的人剔除，然后将M前的人员放到最后，其实又可以看做一个新的，求`N-1`个人的叫号子问题。而通过上面的规律，问题从找人转化为了找坐标，最后只要是哪个坐标就可以通过下标定位人员了。

递归问题，我们首先要写出它的递归公式。递归公司由$x = (y+M)\%N$ ，可以很方便的写出来：

$f(N,M) = (f(N-1,M)+M)\% N$

终止条件为：当n=1时，$f(1,M) = 0$。即只有1个人时，那它的下标一定是0。



有了递归公式，递归实现也就很容易了：

```java
int ysfCycle(int n,int m){
    if(n == 1){
        return 0;
    }
    return ( ysfCycle(n-1,m) + m )%n;
}
```

为了避免递归栈因为N的变大而变得很深，可以改为循环方式：

```java
int ysfCycle(int n,int m){
    int sub = 0;//1个人时为坐标0
    for(int i=1; i<=n ; i++){
        sub = (sub+m)%i;
    }
    return sub;
}
```

带入上面的例子，n=11，m = 3，结果为：6，对滴！搞定。

<img src="img/链表/捕获.PNG" style="zoom:50%;" />



**参考：**

* [约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)
* [约瑟夫环的三种解法](https://cloud.tencent.com/developer/article/1164728) (有递归公式推导过程)

