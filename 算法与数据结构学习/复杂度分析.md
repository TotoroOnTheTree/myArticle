# 复杂度分析

[TOC]

复杂度分析用于检验代码的**执行效率**



**事后统计法：**将代码写出来实实在在跑一次，来进行监控统计

**缺点：**

1. 太依赖测试环境
2. 受数据规模的影响很大



## 时间复杂度分析

### 大O表示法：

所有代码的执行时间$T(n)$与每行代码执行的次数n成正比。

> $T(n) = O( f(n) )$
>
> $f(n)$表示总的代码执行次数
>
> n表示数据规模大小

大O时间复杂度表示法，实际上并不具体表示代码真正的执行时间，而是表示代码执行时间与数据规模增长的变化趋势，所以，也叫做渐进时间复杂度`（asymptotic time complexity)`，简称**时间复杂度**。



随着数据规模增大，低阶、常量、系数并不左右增长趋势，所以可以忽略。



### 如何分析时间复杂度？

1. **只关注循环执行次数最多的那一行代码**
2. **加法法则：总复杂度等于量级最大的那段代码的复杂度**

> for(int i=0; i< 10000; i++){//打印}，对于常量，比如这里的10000，尽管会占用一定量时间，但是在做时间复杂度分析时，还是直接忽略。
>
> 因为时间复杂度是讨论的算法执行效率与数据规模增长的变化趋势。

总的时间复杂度就等于量级最大的那段代码的时间复杂度。

3. **乘法法则：嵌套代码的复杂度登录嵌套内外代码复杂度的乘积**



### 几种常见的时间复杂度

<img src="img/复杂度分析/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="img" style="zoom:50%;" />

#### 多项式量级：

通用解释：执行时间随数据规模的增长，按多项式的比例增长

* 常数阶：$O(1)$ 

> 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

* 对数阶：$O(log^n)$

```C
i=1;
while (i <= n) {
	i = i * 2; 
}
```

> 对数转化：$log_3^n = log_3^2 * log_2^n$，忽略常量系数$log_3^2$

* 线性阶：$O(n)

* 线性对数阶：$O(nlog^n)$
* 平方阶：$O(n^2)$
* 立方阶：$O(n^3)$
* ……
* k次方阶：$O(n^k)$

#### 非多项式量级：

通俗解释：执行时间随着数据规模的增长而暴增，性能很差。

* 指数阶：$O(2^n)$
* 阶乘阶：$O(n!)$





## 空间复杂度分析

类比时间复杂度，其全称是：渐进式空间复杂度。

概念：算法的存储空间与数据规模之间的增加关系。

常用的空间复杂度就是$O(1)、O(n)、O(n^2)$，其他的平时都用不到。



内容小结：

<img src="img/复杂度分析/497a3f120b7debee07dc0d03984faf04.jpg" alt="img" style="zoom:50%;" />



## 浅析最好、最坏、平均、均摊时间复杂度

引入这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。

**1. 最好时间复杂度：** 在最理想的情况下，执行这段代码的时间复杂度

**2. 最坏时间复杂度：** 在最糟糕的情况下，执行这段代码的时间复杂度

**3. (加权)平均时间复杂度/期望时间复杂度：** 

为了更好的表示最好时间复杂度和最坏时间复杂度同时存在的代码，引入平均时间复杂度。

计算方式：考虑每种情况下的概率，相加求平均值。



**4. 均摊时间复杂度/摊还分析法：** 均摊时间复杂度就是一种特殊的平均时间复杂度

均摊时间复杂度的适用范围是：

​		**对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系**，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。





### 实例分析：



```c
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}	
```



代码含义：这段代码就是数组自动扩容，当插入数据长度超过数组长度时，声明一个2倍的数组，并将之前的数据copy到新数组。



最好时间复杂度：大部分情况下，数组都是有位置的，插入就是一个常量级别的复杂度 $O(1)$

最坏见复杂度：当数组满了，需要扩容，这时需要遍历数组一遍，所以复杂度为 $O(n)$

平均见复杂度： 将每种情况出现的概率加起来，
$$
\begin{align*}
& 1*\frac{1}{n+1} + 1*\frac{1}{n+1} + ... + 1*\frac{1}{n+1} + n*\frac{1}{n+1} \\
&=\frac{1+1+...1+n}{n+1}\\
&=\frac{2n}{n+1}\\
&=\frac{2n}{n+1}

\end{align*}
$$
​		省略掉常数，并分子分母同除以n
​		时间复杂度变为$O( 1 )$

均摊见复杂度： 大部分情况都是最好时间复杂度，达到n时扩展数组时为最差时间复杂度。即，每次$O(n)$操作之前都有$n-1$次$O(1)$的操作，平摊下来，每次操作的时间复杂度为$O(1)$。