# 排序算法

[TOC]

常用的排序算法



## 排序算法的分析



**看效率：**

1. 最好、最坏、平均时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 基于比较的算法，要考虑**比较次数**和**交换次数**

**看内存消耗：**

1. 空间复杂度
2. 是不是**原地排序**算法

**看稳定性：**

​	稳定性是说相同的两个值，在排序前和排序后，相对位置有没有改变。改变了就是**不稳定的排序算法**，没改变就是**稳定的排序算法**。

​	为什么要看这个？因为稳定的排序算法，在需要给多个字段排序时，排序次数更少。而如果是非稳定的排序算法，因为每次排序其他字段的顺序都可能变化，那就没办法一个字段一个字段的排序了。而必须写一个能同时给多个字段排序的实现，这个实现也会比较复杂。



## 有序度

概念：有序度**数组**中具有有序关系的元素对个数。

* 有序度的存在关系表示为：$a[i] <= a[j] ， i<j$

* 逆有序度的存在关系表示为：$a[i] > a[j] ， i<j$

* 一组完全有序的数据，他的有序度就是满有序度。比如：`1,2,3,4,5,6,7`，其有序度个数为：$\frac{n(n-1)}{2}$ = 满有序度
* 满有序度 = 有序度 + 逆有序度





---



## 时间复杂度 $O(n^2)$



### 冒泡排序

​	基于比较，由第1个数开始，两个相邻的数作比较，将最大值/最小值冒泡到最后，重复n次。

改进：

1. 设置有序标识：原始的冒泡，每次冒泡过程都需要扫描一次数组的n个数据，要冒泡n次。可以做个标识，如果某次遍历没有数据交换了，那么数组就是有序的了。

2. 已经冒泡到顶的数据，下次冒泡就不比较了，一定是有序的。

**复杂度分析：**

* 最好情况：数据本身是有序的，那么遍历一次就知道了。时间复杂度为：$O(n)$

* 最坏情况：如果数据是倒序的，那么遍历n个数据n次，时间复杂度为：$O(n^2)$。即使是改进后的冒泡，每次冒泡的数据-1，那么遍历的数据是等差数列，求和为：$s_n = na_1 + \frac{n(n-1)}{2}d$，去掉常量和低阶，依然是$O(n^2)$。

* 平均情况：定量分析比较复杂，使用有序度的概念大概推算一下，满有序度为$\frac{n(n-1)}{2}$，去个平均值：$\frac{n(n-1)}{4}$，粗略估计仍然是$O(n^2)$。

**稳定性分析：** 冒泡过程，遇到一样的值，我们可以不交换位置，所以冒泡排序是稳定的排序算法。

**内存消耗：** 冒泡排序是原地排序算法，空间复杂度为$O(1)$



### 插入排序

​	将排序的数据分为已排序、未排序两部分，每次从未排序的部分去一个值，在已排序的部分找到位置，然后将该位置之后的其他数据搬移，腾出该位置，并插入进去。直到数组遍历完成。

**时间复杂度：**  

​	最好情况：数据本身就是有序的，每次从未排序部分取都不用位移，从头遍历到尾，时间复杂度为$O( n)$

​	最坏情况：数据是逆序，每次从未排序部分取都要遍历已排序部分所有数据，次数为：n,n-1,n-1,....,3,2,1，等差数列，和冒泡一样是$O(n^2)$。

​	平均情况：因为有数据搬移工作，数组插入一个数据的时间复杂度为$O(n)$，而n个数据做插入排序，即为 $O( n^2)$





### 选择排序

​	将要排序的数据分为两部分，每次从未排序的部分找到最小的值，放到到已排序部分。









## 时间复杂度 $O(nlogn)$



### 归并排序







### 快速排序



### 堆排序



## 时间复杂度 $O(n)$



### 桶排序



### 基数排序

