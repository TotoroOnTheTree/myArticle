# 排序算法

[TOC]

常用的排序算法



## 排序算法的分析



**看效率：**

1. 最好、最坏、平均时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 基于比较的算法，要考虑**比较次数**和**交换次数**

**看内存消耗：**

1. 空间复杂度
2. 是不是**原地排序**算法

**看稳定性：**

​	稳定性是说相同的两个值，在排序前和排序后，相对位置有没有改变。改变了就是**不稳定的排序算法**，没改变就是**稳定的排序算法**。

​	为什么要看这个？因为稳定的排序算法，在需要给多个字段排序时，排序次数更少。而如果是非稳定的排序算法，因为每次排序其他字段的顺序都可能变化，那就没办法一个字段一个字段的排序了。而必须写一个能同时给多个字段排序的实现，这个实现也会比较复杂。



## 有序度

概念：有序度**数组**中具有有序关系的元素对个数。

* 有序度的存在关系表示为：$a[i] <= a[j] ， i<j$

* 逆有序度的存在关系表示为：$a[i] > a[j] ， i<j$

* 一组完全有序的数据，他的有序度就是满有序度。比如：`1,2,3,4,5,6,7`，其有序度个数为：$\frac{n(n-1)}{2}$ = 满有序度
* 满有序度 = 有序度 + 逆有序度





---



## 时间复杂度 $O(n^2)$



### 冒泡排序

​	基于比较，由第1个数开始，两个相邻的数作比较，将最大值/最小值冒泡到最后，重复n次。

改进：

1. 设置有序标识：原始的冒泡，每次冒泡过程都需要扫描一次数组的n个数据，要冒泡n次。可以做个标识，如果某次遍历没有数据交换了，那么数组就是有序的了。

2. 已经冒泡到顶的数据，下次冒泡就不比较了，一定是有序的。

**复杂度分析：**

* 最好情况：数据本身是有序的，那么遍历一次就知道了。时间复杂度为：$O(n)$

* 最坏情况：如果数据是倒序的，那么遍历n个数据n次，时间复杂度为：$O(n^2)$。即使是改进后的冒泡，每次冒泡的数据-1，那么遍历的数据是等差数列，求和为：$s_n = na_1 + \frac{n(n-1)}{2}d$，去掉常量和低阶，依然是$O(n^2)$。

* 平均情况：定量分析比较复杂，使用有序度的概念大概推算一下，满有序度为$\frac{n(n-1)}{2}$，去个平均值：$\frac{n(n-1)}{4}$，粗略估计仍然是$O(n^2)$。

**稳定性分析：** 冒泡过程，遇到一样的值，我们可以不交换位置，所以冒泡排序是稳定的排序算法。

**内存消耗：** 冒泡排序是原地排序算法，空间复杂度为$O(1)$



### 插入排序

​	将排序的数据分为已排序、未排序两部分，每次从未排序的部分去一个值，在已排序的部分找到位置，然后将该位置之后的其他数据搬移，腾出该位置，并插入进去。直到数组遍历完成。

**时间复杂度：**  

​	最好情况：数据本身就是有序的，每次从未排序部分取都不用位移，从头遍历到尾，时间复杂度为$O( n)$

​	最坏情况：数据是逆序，每次从未排序部分取都要遍历已排序部分所有数据，次数为：n,n-1,n-1,....,3,2,1，等差数列，和冒泡一样是$O(n^2)$。

​	平均情况：因为有数据搬移工作，数组插入一个数据的时间复杂度为$O(n)$，而n个数据做插入排序，即为 $O( n^2)$





### 选择排序

​	将要排序的数据分为两部分，每次从未排序的部分找到最小的值，放到到已排序部分。



**时间复杂度：**

​	最好情况：找最小部分需要遍历数组，所以n个数据的排序，时间复杂度为：$O( n^2)$

​	最坏情况：数据完全逆序，仍然要遍历整个数组找到最小值，复杂度为：$O(n^2)$ 

​	平均情况：不用说了，$O(n^2)$





---



## 时间复杂度 $O(nlogn)$



### 1. 归并排序

思路：将一组数据分为2部分分别排序，然后再将两部分有序数组进行有序数据合并。各部分又可以继续二分，直到只有1个值时返回。

思想：分治

代码：见`sort.MergeSort`

**时间复杂度**

​	归并的递推时间公式为：$T(a) = T(b) + T(c) + k$，k为合并操作的时间消耗。使用该公式进行推导可以得出时间复杂度为：$O(nlog^n)$

**空间复杂度**：$O(n)$

**稳定性**：

**是否是原地排序算法**：不是，在合并时需要额外的空间



### 2. 快速排序（`Quicksort`）

思路：和归并相似，将一组数据分为2部分，但是不是从中间。而是选取一个分区点（`pivot`），将比这个数小的数据移动到左方，大的移动到右方，然后分别对左右两部分排序，重复这个过程。最后得到的数组就自然有序了。

**思想**：分治

**递归公式**：`quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)`，q是选取的`pivot`

**分区**：

分区时如果不考虑消耗，那么声明两个临时数组分别放置比pivot小、大的数据，然后合并到原数组就可以了，但快排就不是原地排序算法了。所以这里的分区操作有技巧，见图。

<img src="img/算法—排序算法/086002d67995e4769473b3f50dd96de7.jpg" alt="img" style="zoom:50%;" />

**归并和快排的对比**：

归并是**由下向上**的，快排是**由上向下**的。因为合并函数的原因，归并不是原地排序算法，而快排通过巧妙的分区设计，是原地排序算法，减少了内存占用。

**稳定性**：不稳定

**时间复杂度**：

​	如果pivot每次选举都正好是中间，那么时间复杂度和归并是一样的：$O(nlogn^n)$

​	时间复杂度递推公司为：

````
T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
````

​	极端情况下，数组是有序的，每次选举pivot都是最大那个数据，那么每次分区都是不平衡的，只能排除掉pivot那个数据。剩余的n-1个数据，再次分区。一直重复n次才能排序完成。平均下来，每次分区需要扫描数据 $\frac{n}{2}$次。

​	

​	//todo 递归公式分析时间复杂度很复杂，使用递归树分析快排时间复杂度





**pivot的选择：**

* 选取最后一个
* 三数取中法：首、尾、中间各取一个数，找到中间值作为pivot。排序数据很大的话，也可以5个数去中间值，10个数取中间值
* 随机法：从概率上来讲，不大可能每次都选到最差的那个情况。





### 3. 堆排序







---



## 时间复杂度 $O(n)$



### 桶排序



### 基数排序

