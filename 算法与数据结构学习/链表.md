

## 特点：

1. 链表和数组在插入、删除、查找的时间复杂度上正好完全相反：

<img src="img/链表/4f63e92598ec2551069a0eef69db7168.jpg" alt="img" style="zoom:33%;" />



2. 数组需要一整块连续的内存空间，而链表通过指针将一组零散的内存块串联起来。
3. 数组对cpu预读更友好







**时间复杂度：** 

​	插入、删除：$O(1)$

​	查找： $O(n)$



## 常见链表：

### 单链表

​	**组成：**结点、后继指针（next)

### 双向链表

​	**组成：**结点、后继指针（next)、前驱指针（prev）

​	在删除给定节点时比单链表高效，因为不用在遍历一遍找到前一个节点是谁。

### 循环链表

​	将单链表的尾结点指向首结点即为循环链表

​	常用于解决 **约瑟夫问题**

### 双向循环链表



## 如何快速写出链表代码

1. 理解指针或引用的含义
2. 警惕指针丢失和内存泄漏
   1. 插入节点时，一定要注意操作顺序。现将下个结点的引用放入要插入节点的next，再去修改上个节点的next指向当前节点。
   2. 删除结点时，记得手动释放空间
3. 利用哨兵简化实现难度
   1. 引入哨兵，可以将第一个结点和最后一个结点的特殊情况转换为普通结点的增删操作。
   2. 带哨兵的叫**带头链表**，不带的叫**不带头链表**
4. 重点留意边界条件
5. 举例画图辅助思考
6. 多写多练，没有捷径





## 实战

### 1. 链表实现

1. 单链表实现 ：见`LinkedListSimple`

2. 单链表+哨兵 ：见`LinkedListSentry（逆序链表）`、`LinkedListSentry2（正序链表）`

3. 双向链表：

   



### 2. LRU缓存淘汰算法

#### 策略：

​	FIFO(first in , first out)：先进先出策略

​	LFU(latest frequently used)：最少使用策略

​	LRU(latest recently used)：最近最少使用策略

#### 思路：

维护一个有序链表，越早访问的数据越接近链表尾部

读取数据时，从链表中查找到该结点，如果存在则删除该结点，将其添加到链表头。如果没有找到，则检查链表是否满了，没满则直接添加到头部；满了则删除尾结点，再添加到头部。



### 3. 约瑟夫环问题