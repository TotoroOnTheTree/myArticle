# 第三课：数组

指存储方式是数组的算法



思路：从特殊到一般

## 题目一：和为定值得两个数？

​	输入一个数组`A[0...N-1]`和一个数字Sum，在数组中查找两个数$A_i，Aj$，使得$A_i+A_j=Sum$。

### 暴力法

i,j都为n，暴力比较

```java
//todo
```



### 排序法

先对数组排序，然后两个指针，一个从首走，一个从尾走，然后：

1. 如果 oring[i] + origin[j] < sum ，i++

2. 如果 大于，j--;



### Hash法



#### **哈希函数**

**djb2**

```java
//todo
```



**sdbm**

```java
//todo
```



**MurmurHash**

```java
//todo
```



**Hash方案的可行性**

步骤：

1. 选择适当的hash函数，将原数组建立为hash结构
2.  遍历数组a[i]，计算Hash(Sum - a[i]) 是否存在

**算法可行性**

时间复杂度：$O(n)$

空间复杂度：$O(n)$



## 题目二：和为定值得m个数

​	已知数组A[0...N-1]，给定某数值sum，自熬出数组中的若干个数，使得这些数额和为sum。



### 直接递归法（枚举）

递归考察本身+下一个数，或者跳过下一个数的和是否等于sum，如果小于则继续递归，等于就返回/打印，大于？

```java
//todo
```





### 分支限界

通过假设数组的所有元素都大于0来简化问题，且假设一定能找到结果，推出如下结论：

1. 假设第 $i$ 位可以取，那么：

   1.  $Sum(i-1)+A[i] < sum$ 成立，即加上$A[i]$不会使结果超出sum。
   2. $Sum(i-1) + Sum(i+1,N-1) >= sum$成立，即除了$A[i]$外的和一定是大于sum的，否则就没有解了。

2. 假设第$i$位不可以取，那么：

   1.  $Sum(i-1)+A[i] >= sum$ 成立，即加上$A[i]$会使结果超出sum。
   2. ……

   

```java
//todo
```



**存在负数的处理方法**

将数组排序，将所有正数的和作为分支界限，砍掉会使值小于sum的负数。

```java
//todo
```





## 题目三：荷兰国旗问题

​	现有红、白、蓝三个不同颜色的小球，乱序排列在一起，请重新排列这些小球，是的红白蓝三色的同颜色的求在一起。

 

### 快速排序法

建立三个指针，begin=0、current=0、end=N-1，current往后推移，遇到如下情况：

1. 如果是蓝色则current指向的元素和end指向的元素交换，然后`end--`，将end的位置往前走。
2. 如果current是白色，因为白色本来就放在中间位置，所以不用交换，直接`current++`
3. 如果current是红色，那么：
   1. 如果current==begin，那么说明begin、current位置前的球都是红色，直接`current++`、`begin++`。
   2. 如果current≠begin，那么current指向的球和begin指向的交换位置，`begin++`。



```java
//todo
```





**优化：**

从上面的情况分析可知，在current扫过的区间$[0,current]$，一定不会出现篮球，因为篮球都被替换到最后了。这时，要么遇到白球，current和begin一起向后+1，要么current遇到白球+1，那begin指向的一定是白球。

也就是说，如果current如果和begin不相等，那一定是遇到了白球，Array[begin]=白球。

这里就可以省掉一个交换。



```java
//todo
```





**乌克兰国旗问题**

​	如果小球颜色是2种，那对应的就是乌克兰国旗问题了。

奇偶排序

正负排序





## 题目三：完美洗牌算法

​	长度为2n 的数组$\{a1,a2,a3,...,an,b1,b2,b3,...,bn\}$，经过整理后变成$\{ b1,a1,b2,a2,...,bn,an\}$，要求时间复杂度$O(n)$，空间复杂度$O(1)$。





### 中间交换

从中间开始依次交换

<img src="img/数组/middle_exchange.png" style="zoom:50%;" />

时间复杂度 ：$O (n^2)$

### 完美洗牌



```
//todo 网上找完美洗牌算法

```



#### 进一步

1. 要求输出$a1,b1,a2,b2,a3,b3,...an,bn$怎么办呢？



```java
//todo
```



* 先把a部分和b部分交换，或者最后再交换相邻的两个位置--不够美观。

* 原数组第一个和最后一个不变，中间的$2*(n-1)$项用原始的完美洗牌算法。



2. 逆向过程呢，比如：$b1,a1,b2,a2,...bn,an$，变为 $a1,a2,a3,...,an,b1,b2,b3,...,bn$ ?

```java
//todo	
```

* 既然完美洗牌问题可以通过若干圈来解决，那么，逆向过程仍然存在若干圈，并且$2*n=(3^{k-1})$这种长度的数组，恰好只有k个圈的结论仍然成立。



3. 完美洗多副牌呢？比如：$a1,a2,..,an,b1,b2,...,bn,c1,c2,...,cn$ ，变为 $c1,b1,a1,...,cn,bn,an$ ，该怎么做呢？

```java
//todo
```

* 看视频结论把，这里可以推导一下。把元根啥的查一下。

















